[TOC]

# 进程控制

## 进程标识

每个进程都有一个非负整型表示的唯一进程ID。

虽然是唯一的，但是进程ID是可以复用的。当一个进程终止后，其进程ID久成为复用的候选者。大多数UNIX系统实现延迟复用算法，使得赋予新建进程的ID不同于最近终止进程所使用的ID。

系统中的一些专用进程：
- ID为0的进程通常是调度进程，常常被称为`交换进程（swapper）`。该进程是内核的一部分，它不执行任何磁盘上的程序，因此也被称为系统进程。
- 进程ID 1通常是init进程，在自举过程结束时由内核调用。该进程的程序文件在UNIX的早起版本中是`/etc/init`，在较新版本中是`/sbin/init`。此进程负责在自举内核后启动一个UNIX系统。init通常读取与系统有关的初始化文件（/etc/rc*文件或/etc/inittab文件，以及在/etc/init.d中的文件），并将系统引导到一个状态（如多用户）。init进程绝不会终止。它是一个普通的用户进程（与交换文件不同，它不是内核中的系统进程），但它以超级用户特权运行。init会成为所有孤儿进程的父进程。

## 函数fork

由fork创建的新进程被称为**子进程（child process）**。fork函数被调用一次，但返回两次。两次但会的区别是子进程的返回值是0，而父进程的返回值则是新建子进程的进程ID。

子进程是父进程的副本。例如，子进程获得父进程数据空间、堆和栈的副本。注意，这是子进程所拥有的副本。父进程和子进程并不共享这些储存空间部分。父进程和子进程共享正文段。

由于fork之后通跟着exec，所以现在很多实现并不执行一个父进程数据段、栈和堆的完全副本。作为替代，使用了**写时复制（Copy-On-Write，COW）**技术。这些区域由父进程和子进程共享，而且内核将它们的访问权限改变为只读。如果父进程和子进程中的任何一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储系统中的一“页”。

在fork之后父进程先执行还是子进程先执行是不确定的，这取决于内核所使用的调度算法。

### 文件共享

fork的另一个特性是父进程的所有打开文件描述符都被复制到子进程中。父进程和子进程每个相同的打开描述符共享一个表项。重要的一点是，父进程和子进程共享同一个文件偏移量。