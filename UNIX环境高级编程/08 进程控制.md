[TOC]

# 进程控制

## 进程标识

每个进程都有一个非负整型表示的唯一进程ID。

虽然是唯一的，但是进程ID是可以复用的。当一个进程终止后，其进程ID久成为复用的候选者。大多数UNIX系统实现延迟复用算法，使得赋予新建进程的ID不同于最近终止进程所使用的ID。

系统中的一些专用进程：
- ID为0的进程通常是调度进程，常常被称为`交换进程（swapper）`。该进程是内核的一部分，它不执行任何磁盘上的程序，因此也被称为系统进程。
- 进程ID 1通常是init进程，在自举过程结束时由内核调用。该进程的程序文件在UNIX的早起版本中是`/etc/init`，在较新版本中是`/sbin/init`。此进程负责在自举内核后启动一个UNIX系统。init通常读取与系统有关的初始化文件（/etc/rc*文件或/etc/inittab文件，以及在/etc/init.d中的文件），并将系统引导到一个状态（如多用户）。init进程绝不会终止。它是一个普通的用户进程（与交换文件不同，它不是内核中的系统进程），但它以超级用户特权运行。init会成为所有孤儿进程的父进程。

## 函数fork

由fork创建的新进程被称为**子进程（child process）**。fork函数被调用一次，但返回两次。两次但会的区别是子进程的返回值是0，而父进程的返回值则是新建子进程的进程ID。

子进程是父进程的副本。例如，子进程获得父进程数据空间、堆和栈的副本。注意，这是子进程所拥有的副本。父进程和子进程并不共享这些储存空间部分。父进程和子进程共享正文段。

由于fork之后通跟着exec，所以现在很多实现并不执行一个父进程数据段、栈和堆的完全副本。作为替代，使用了**写时复制（Copy-On-Write，COW）**技术。这些区域由父进程和子进程共享，而且内核将它们的访问权限改变为只读。如果父进程和子进程中的任何一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储系统中的一“页”。

在fork之后父进程先执行还是子进程先执行是不确定的，这取决于内核所使用的调度算法。

### 文件共享

fork的另一个特性是父进程的所有打开文件描述符都被复制到子进程中。父进程和子进程每个相同的打开描述符共享一个表项。重要的一点是，父进程和子进程共享同一个文件偏移量。

在fork之后处理文件描述符有以下两种常见的情况。

1. 父进程等待子进程完成。这种情况下，父进程无需对其描述符做任何事情。当子进程终止后，它曾进行过读、写操作的任一共享描述符的文件偏移量已经做了相应的更新。
2. 父进程和子进程各自执行不同的程序段。在这种情况下，在fork之后，父进程和子进程各自关闭他们不需使用的文件描述符。

除打开文件之外，父进程和很多属性也由子进程继承，包括：

- 实际用户ID、实际组ID、有效用户ID、有效组ID
- 附属组ID
- 进程组ID
- 会话ID
- 控制终端
- 设置用户ID标志和设置组ID标志
- 当前工作目录
- 根目录
- 文件模式创建屏蔽字
- 信号屏蔽和安排
- 对任一打开文件描述符的执行时关闭（close-on-exec）标志
- 环境
- 连接的共享储存段
- 储存映像
- 资源限制

父进程和子进程之间的区别具体如下:

- fork返回值不同
- 进程ID不同
- 这两个进程的父进程ID不同
- 子进程的`tms_utime` 、`tms_stime`、`tms_cutime`、`tms_ustime`的值设置为0
- 子进程不继承父进程设置的文件锁
- 子进程的未处理闹钟被清除
- 子进程的未处理信号集设置为空集

使fork失败的两个主要原因是：

1. 系统中已经有了太多进程
2. 该用户ID的进程总数超过了系统限制。

