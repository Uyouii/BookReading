# 内存寻址

## 内存地址

## 硬件中的分段

## Linux中的分段

## 硬件中的分页

### 硬件高速缓存

为了缩小CPU和RAM之间的速度不匹配，引入了**硬件高速缓存内存(hardware cache memory)**

硬件高速缓存基于著名的**局部性原理(locality principle)**，该原理既适用程序结构也适用于数据结构。这表明由于程序的循环结构及相关数组可以组织成线性数组，最近最常用的相邻地址在最近的将来又被用到的可能性极大。

高速缓存单元插在分页单元和主内存之间。它包含一个**硬件高速缓存内存(hardware cache memory)**和一个**高速缓存控制器(cache controller)**。高速缓存内存中存放内存真正的行。高速缓存控制器存放一个表项数组，每个表项对应高速缓存内存中的一个行。每个表项有一个标签(tag)和描述高速缓存行状态的几个标志(flag)。

这种物理内存地址通常分为3组：最高几位对应标签，中间几位对应高速缓存控制器的字集索引，最低几位对应行内的偏移量。

> 处理器硬件高速缓存

![](https://note.youdao.com/yws/api/personal/file/CEF362F1ECF54FF093D2A854A9EB8940?method=download&shareKey=65e9dfee767bbb515abe16c432a89fab)

当访问一个RAM储存单元时，CPU从物理地址中提取出子集的索引号并把子集中所有行的标签与物理地址的高几位比较。如果发现某一行的标签与这个物理地址的高位相同，则CPU命中一个高速缓存(cache hit)；否则，高速缓存没有命中(cache miss)。

当命中一个高速缓存时，高速缓存控制器执行不同的操作。

对于读操作，控制器从高速缓存行中选择数据并送到CPU寄存器；不需要访问RAM因而节约了CPU时间，因此，高速缓存系统起到了应有的作用。

对于写操作，控制器可能采用以下两个基本策略之一：

- **通写(write-through)**：控制器总是既写RAM也写高速缓存行
- **回写(write-back)**：回写的方式只更新高速缓存行，不改变RAM内容，提供了更快的功效。只有当CPU执行一条要求刷新高速缓存表项的指令时，或者当一个FLUSH硬件信号产生时（通常在高速缓存不命中之后），高速缓存控制器才把高速缓存行写回到RAM中。

当高速缓存没有命中时，高速缓存行被写回到内存中，如果有必要的话，把正确的行从RAM中取出放到高速缓存行的表项中。





## Linux中的分页

