## 进程

### 进程、轻量级进程和线程

从内核观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的实体。

Linux使用轻量级进程(lightweight process)对多线程应用程序提供更好的支持。两个轻量级进程基本上可以共享一些资源，诸如地址空间、打开的文件等等。

### 进程描述符

进程描述符(process descriptor)——进程描述符都是task_struct类型结构，它的字段包含了与一个进程相关的所有信息。

> linux 进程描述符

![](https://note.youdao.com/yws/api/personal/file/5383C027E84442578519B055EB01E101?method=download&shareKey=26e9eaa6aea258d172b4b84db68a2520)

#### 进程状态

进程描述符中的state字段描述了进程当前所处的状态。它由一组标志组成，其中每个标志描述一种可能的进程状态。在当前的Linux版本中，这些状态是互斥的，因此，严格意义上说，只能设置一种状态；其余的标志将被清除。

- **可运行状态(TASK_RUNNING)**
  - 进程要么在CPU上执行，要么装备执行
- **可中断的等待状态(TASK_INTERRUPTIBLE)**
  - 进程被挂起（睡眠），直到某个条件变为真。产生一个硬件中断，释放进程正等待的系统资源，或传递一个信号都是可以唤醒进程的条件（把进程的状态放回到TASK_RUNNING）。
- **不可中断的等待状态(TASK_UNINTERRUPTIBLE)**
  - 与可中断的等待状态类似，但有一个例外，把信号传递到睡眠进程不能改变它的状态。这种状态很少用到，但在一些特殊的情况下（进程必须等待，直到一个不能被中断的事件发生），这种状态是很有用的。
  - 例如，当进程打开一个设备文件，其相应的设备驱动程序开始探测相应的硬件设备时会用到这种状态。探测完成以前，设备驱动程序不能被中断，否则，硬件设备会处于不可预知的状态。
- **暂停状态(TASK_STOPPED)**
  - 进程的执行被暂停。当进程接收到SIGSTOP、SIGTSTP、SIGTTIN或SIGTTOU信号后，进入暂停状态。
- **跟踪状态(TASK_TRACED)**
  - 进程的执行已由debugger程序暂停。当一个进程被另一个进程监控时，任何信号都可以把这个进程置于TASK_TRACED状态。

还有两个进程状态既可以存放在进程描述符的state字段中，也可以存放在exit_state字段中。从这两个字段名称可以看出，只有当进程的执行被终止时，进程的状态才会改变为这两种状态中的一种。

- **僵死状态(EXIT_ZOMBIE)**

  - 进程的执行被终止，但是，父进程还没有发布wait4()或waitpid()系统调用来返回有关死亡进程的信息。发布wait()类系统调用前，内核不能丢弃包含在死进程描述符中的数据，因为父进程可能还需要它。

- **僵死撤销状态(EXIT_DEAD)**

  - 最终状态：由于父进程刚发出wait4()或waitpid()系统调用，因而进程由系统删除。为了防止其他执行线程在同一个进程上也执行wait()类系统调用(这是一种竞争状态)，而把进程的状态由僵死(EXIT_ZOMBIE)状态改为僵死撤销状态(EXIT_DEAD)。

#### 标识一个进程

能够独立调度的每个执行上下文都必须拥有它自己的进程描述符。

进程和进程描述符有非常严格的一一对应关系，使得32位的进程描述符地址可以很容易的标识进程。进程描述符指针指向这些地址，内核对进程的大部分引用是通过进程描述符指针进行的。

类Unix操作系统允许用户使用一个叫进程描述符processID(或PID)的数来标识进程，PID存放在进程描述符的pid字段中。

PID的值有一个上限，默认情况下，最大的PID号时32767(`PID_MAX_DEFAULT` - 1)；系统管理员可以通过往`/proc/sys/kernel/pid_max`这个文件中写入一个更小的值来减小PID的上限值。在64位的体系结构中，系统管理员可以把PID的上限扩大到4194303。

由于循环使用PID编号，内核必须通过管理一个`pidmap_array`位图来表示当前已分配的PID号和闲置的PID号。因为一个页框包含32768个位，所以在32位体系结构中`pidmap_array`位图存放在一个单独的页中。然而在64位体系结构中，需要为PID位图增加更多的页。系统会一直保存这些页不被释放。

Unix希望同一组的线程有共同的PID。例如，可以把信号发送给指定PID的一组线程，这个信号会作用于该组中的所有线程。

Linux遵照这个标准引入了线程组的表示。一个线程组的所有线程使用和该线程组的领头线程(thread group leader)相同的PID，也就是该组中的第一个轻量级进程的PID，它被存入进程描述符的`tgid`字段中。`getpid()`系统调用返回当前进程的`tgid`值而不是`pid`值，因此，一个多线程应用的所有线程共享相同的PID。

##### 进程描述符处理

进程是动态实体，内核必须能够同时处理很多进程，并把进程描述符存放在动态内存中。

对每个进程来说，Linux都把两个不同的数据结构紧凑地存放在一个单独为进程分配的储存区域：一个是与进程描述符相关的小数据结构`thread_info`，叫做线程描述符。另一个是内核态的进程堆栈。这块储存区域的大小通常为8192个字节(两个页框)。考虑到效率的因素，内核让这8K空间占据连续的两个页框并让第一个页框的起始地址是2^13的倍数。

内核态的进程访问处于内核数据段的栈，这个栈不同于用户态的进程所用的栈。因为内核控制器路径使用很少的栈，因此只需要几千字节的内核态堆栈。所以，对于内核栈和`thread_info`结构来说，8KB足够了。

> thread_info 结构和进程内核存放在两个连续的页框中

![](https://note.youdao.com/yws/api/personal/file/D0B0C46090864F248B3F60DB36567363?method=download&shareKey=952119ee0f466af5385c6c8bb7efe9da)

esp寄存器是CPU栈指针，用来存放栈顶单元的地址。从用户态切换到内核态以后，进程的内核栈总是空的，因此，esp寄存器指向这个栈的顶端。

c语言使用下列的联合结构方便的表示一个进程的线程描述符和内核栈:

```
union thread_union {
	struct thread_info thread_info;
    unsigned long stack[2048]; /* 对4K的栈数组下标是1024 */
};
```

##### 标识当前进程

`thread_info`结构与内核态堆栈之间紧密结合提供的主要好处是：内核可以很容易从esp寄存器的值获取当前在CPU运行进程的`thread_info`结构的地址。如果`thread_union`结构长度是8K，内核则屏蔽掉esp的低13位有效位就可以获得`thread_info`结构的基地址；而如果`thread_union`结构长度是4K，内核则需要屏蔽掉esp的低12位有效地址。

进程最常用的是进程描述符地址而不是`thread_info`结构的地址，通过`thread_info`的task指针可以很容易的获取到进程描述符。

##### 进程链表

每个`task_struct`结构都包含一个`list_head`类型的`tasks`字段，这个类型的`prev`和`next`字段分别指向前面和后面的`task_struct`元素。

##### TASK_RUNNING状态的进程链表

当内核寻找一个新进程在CPU运行时，必须只考虑可运行进程(即处在TASK_RUNNING状态的进程)

提高调度程序运行速度的诀窍是建立多个可运行进程链表，每种进程优先权对应一个不同的链表。每个`task_struct`描述符包含一个`list_head`类型的字段`run_list`。如果进程的优先权等于k，run_list字段把该进程链入优先权为k的可运行进程的链表中。

#### 进程间关系

> 进程描述符中表示进程亲属关系的字段描述

| 字段名      | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| real_parent | 指向创建了P的进程的描述符，如果P的父进程不再存在，就指向进程1(init)的描述符（因此，如果用户运行一个后台进程而且推出了shell，后台进程就会成为init的子进程） |
| parent      | 指向P的当前父进程（这种进程的子进程终止时，必须向父进程发信号）。它的值通常与`real_parent`一致，但偶尔也可以不同，例如，当另一个进程发出监控P的ptrace()系统调用请求时 |
| children    | 链表的头部，链表中的所有元素都是P创建的子进程                |
| sibling     | 指向兄弟进程链表的下一个元素或前一个元素的指针，这些兄弟进程的父进程都是P |

##### pidhash表及链表

由于需要跟踪进程间的关系，PID散列表中使用的数据结构非常复杂。

PID散列表的数据结构是四个pid结构的数组，它在进程描述符的pids字段中。

> pid结构的字段

```c
struct pid
{
	int nr;							// pid的数值
	struct hlist_node pid_chain;	// 链接散列表的下一个和前一个元素
	struct list_head pid_list;		// 每个pid的进程链表头
};
```

> PID散列表

![](https://note.youdao.com/yws/api/personal/file/25275D69697641F3AFD4888FF798D311?method=download&shareKey=571ba311ddbb61859cf21834698725fe)



#### 如何组织进程

