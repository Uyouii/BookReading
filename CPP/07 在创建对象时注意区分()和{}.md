## 07  在创建对象的时候区分()和{}

在C++中，指定初始化的方式包括使用小括号、等号或者是大括号：

```cpp
int x(0);             // initializer is in parentheses

int y = 0;            // initializer follows "="

int z{ 0 };           // initializer is in braces
```

在很多情况下，使用一个等号和一对大括号也是可以的：

```cpp
int z = { 0 };        // initializer uses "=" and braces
```

c++中，等号加大括号这种用法和之右大括号的语法同样处理。这里虽然有个等号，但是里面是没有发生赋值的。

像int这样的内建型别，初始化和赋值不过是学术之争，但是对于用户定义的型别，还是有把初始化和赋值分开的必要，这两种行为背后调用的是不同的函数。

```cpp
Widget w1;            // call default constructor

Widget w2 = w1;       // not an assignment; calls copy ctor 调用复制构造函数

w1 = w2;              // an assignment; calls copy operator= 调用复制赋值运算符
```

C++11中引入了统一初始化：单一的、至少从概念上可以用于一切场合、表达一切意思的初始化。它的基础是大括号形式，因此也可以称为大括号初始化(braced initialization)。

e.g.

```cpp
std::vector<int> v{ 1, 3, 5 }; // v's initial content is 1, 3, 5
```

大括号同样可以用来为非静态成员函数指定默认初始化值，也可以使用"="的初始化语法，却不能使用小括号。

```cpp
class Widget {
  …

private:
  int x{ 0 };                  // fine, x's default value is 0
  int y = 0;                   // also fine
  int z(0);                    // error!
};
```

不可复制对象(例如std::atomic型别的对象)可以采用大括号和小括号来进行初始化，却不能使用“=”：

```cpp
std::atomic<int> ai1{ 0 };     // fine

std::atomic<int> ai2(0);       // fine

std::atomic<int> ai3 = 0;      // error!
```

